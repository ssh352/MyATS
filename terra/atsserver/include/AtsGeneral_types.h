/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef AtsGeneral_TYPES_H
#define AtsGeneral_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "AtsType_types.h"


namespace AtsGeneral {

class FeedSourceMsg;

class ConnectionMsg;

class LogMsg;

class OrderMsg;

class QuoteMsg;

class ExecMsg;

class ListQuoteMsg;

class ListExecMsg;

class ListOrderMsg;

class ListLogMsg;

class PositionMsg;

class FeedMsg;

class AtsInstrumentMsg;

class AtsMsg;

class FeesStructMsg;

class InstrumentClassMsg;

class MaturityMsg;

class UnderlyingMsg;

class TradingPeriodMsg;

class TradingPeriodManagerMsg;

class IntraDataMsg;

class AESDataMsg;

typedef struct _FeedSourceMsg__isset {
  _FeedSourceMsg__isset() : Name(false), Status(false), Activated(false) {}
  bool Name :1;
  bool Status :1;
  bool Activated :1;
} _FeedSourceMsg__isset;

class FeedSourceMsg {
 public:

  FeedSourceMsg(const FeedSourceMsg&);
  FeedSourceMsg& operator=(const FeedSourceMsg&);
  FeedSourceMsg() : Name(), Status(( ::AtsType::FeedSourceStatus::type)0), Activated(0) {
  }

  virtual ~FeedSourceMsg() throw();
  std::string Name;
   ::AtsType::FeedSourceStatus::type Status;
  bool Activated;

  _FeedSourceMsg__isset __isset;

  void __set_Name(const std::string& val);

  void __set_Status(const  ::AtsType::FeedSourceStatus::type val);

  void __set_Activated(const bool val);

  bool operator == (const FeedSourceMsg & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(Status == rhs.Status))
      return false;
    if (!(Activated == rhs.Activated))
      return false;
    return true;
  }
  bool operator != (const FeedSourceMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FeedSourceMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FeedSourceMsg &a, FeedSourceMsg &b);

inline std::ostream& operator<<(std::ostream& out, const FeedSourceMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ConnectionMsg__isset {
  _ConnectionMsg__isset() : Name(false), Status(false), TradingAllowed(false), New(false), Mod(false), Can(false), Ack(false), Rej(false), NAck(false), Exe(false), RiskDegree(false) {}
  bool Name :1;
  bool Status :1;
  bool TradingAllowed :1;
  bool New :1;
  bool Mod :1;
  bool Can :1;
  bool Ack :1;
  bool Rej :1;
  bool NAck :1;
  bool Exe :1;
  bool RiskDegree :1;
} _ConnectionMsg__isset;

class ConnectionMsg {
 public:

  ConnectionMsg(const ConnectionMsg&);
  ConnectionMsg& operator=(const ConnectionMsg&);
  ConnectionMsg() : Name(), Status(( ::AtsType::ConnectionStatus::type)0), TradingAllowed(0), New(0), Mod(0), Can(0), Ack(0), Rej(0), NAck(0), Exe(0), RiskDegree(0) {
  }

  virtual ~ConnectionMsg() throw();
  std::string Name;
   ::AtsType::ConnectionStatus::type Status;
  bool TradingAllowed;
  int32_t New;
  int32_t Mod;
  int32_t Can;
  int32_t Ack;
  int32_t Rej;
  int32_t NAck;
  int32_t Exe;
  double RiskDegree;

  _ConnectionMsg__isset __isset;

  void __set_Name(const std::string& val);

  void __set_Status(const  ::AtsType::ConnectionStatus::type val);

  void __set_TradingAllowed(const bool val);

  void __set_New(const int32_t val);

  void __set_Mod(const int32_t val);

  void __set_Can(const int32_t val);

  void __set_Ack(const int32_t val);

  void __set_Rej(const int32_t val);

  void __set_NAck(const int32_t val);

  void __set_Exe(const int32_t val);

  void __set_RiskDegree(const double val);

  bool operator == (const ConnectionMsg & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(Status == rhs.Status))
      return false;
    if (!(TradingAllowed == rhs.TradingAllowed))
      return false;
    if (!(New == rhs.New))
      return false;
    if (!(Mod == rhs.Mod))
      return false;
    if (!(Can == rhs.Can))
      return false;
    if (!(Ack == rhs.Ack))
      return false;
    if (!(Rej == rhs.Rej))
      return false;
    if (!(NAck == rhs.NAck))
      return false;
    if (!(Exe == rhs.Exe))
      return false;
    if (!(RiskDegree == rhs.RiskDegree))
      return false;
    return true;
  }
  bool operator != (const ConnectionMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ConnectionMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ConnectionMsg &a, ConnectionMsg &b);

inline std::ostream& operator<<(std::ostream& out, const ConnectionMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LogMsg__isset {
  _LogMsg__isset() : TimeStamp(false), Message(false) {}
  bool TimeStamp :1;
  bool Message :1;
} _LogMsg__isset;

class LogMsg {
 public:

  LogMsg(const LogMsg&);
  LogMsg& operator=(const LogMsg&);
  LogMsg() : TimeStamp(), Message() {
  }

  virtual ~LogMsg() throw();
  std::string TimeStamp;
  std::string Message;

  _LogMsg__isset __isset;

  void __set_TimeStamp(const std::string& val);

  void __set_Message(const std::string& val);

  bool operator == (const LogMsg & rhs) const
  {
    if (!(TimeStamp == rhs.TimeStamp))
      return false;
    if (!(Message == rhs.Message))
      return false;
    return true;
  }
  bool operator != (const LogMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LogMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LogMsg &a, LogMsg &b);

inline std::ostream& operator<<(std::ostream& out, const LogMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _OrderMsg__isset {
  _OrderMsg__isset() : Code(false), Id(false), TimeStamp(false), Active(false), Way(false), Action(false), TradingType(false), Quantity(false), Price(false), ExecQty(false), ExecPrice(false), BookQty(false), Status(false), Portfolio(false), LastReason(false), Ack_Cancel_Ratio(false), OpenClose(false) {}
  bool Code :1;
  bool Id :1;
  bool TimeStamp :1;
  bool Active :1;
  bool Way :1;
  bool Action :1;
  bool TradingType :1;
  bool Quantity :1;
  bool Price :1;
  bool ExecQty :1;
  bool ExecPrice :1;
  bool BookQty :1;
  bool Status :1;
  bool Portfolio :1;
  bool LastReason :1;
  bool Ack_Cancel_Ratio :1;
  bool OpenClose :1;
} _OrderMsg__isset;

class OrderMsg {
 public:

  OrderMsg(const OrderMsg&);
  OrderMsg& operator=(const OrderMsg&);
  OrderMsg() : Code(), Id(0), TimeStamp(), Active(0), Way(( ::AtsType::OrderWay::type)0), Action(( ::AtsType::OrderAction::type)0), TradingType(0), Quantity(0), Price(0), ExecQty(0), ExecPrice(0), BookQty(0), Status(( ::AtsType::OrderStatus::type)0), Portfolio(), LastReason(), Ack_Cancel_Ratio(), OpenClose(( ::AtsType::OrderOpenClose::type)0) {
  }

  virtual ~OrderMsg() throw();
  std::string Code;
  int32_t Id;
  std::string TimeStamp;
  bool Active;
   ::AtsType::OrderWay::type Way;
   ::AtsType::OrderAction::type Action;
  int32_t TradingType;
  int32_t Quantity;
  double Price;
  int32_t ExecQty;
  double ExecPrice;
  int32_t BookQty;
   ::AtsType::OrderStatus::type Status;
  std::string Portfolio;
  std::string LastReason;
  std::string Ack_Cancel_Ratio;
   ::AtsType::OrderOpenClose::type OpenClose;

  _OrderMsg__isset __isset;

  void __set_Code(const std::string& val);

  void __set_Id(const int32_t val);

  void __set_TimeStamp(const std::string& val);

  void __set_Active(const bool val);

  void __set_Way(const  ::AtsType::OrderWay::type val);

  void __set_Action(const  ::AtsType::OrderAction::type val);

  void __set_TradingType(const int32_t val);

  void __set_Quantity(const int32_t val);

  void __set_Price(const double val);

  void __set_ExecQty(const int32_t val);

  void __set_ExecPrice(const double val);

  void __set_BookQty(const int32_t val);

  void __set_Status(const  ::AtsType::OrderStatus::type val);

  void __set_Portfolio(const std::string& val);

  void __set_LastReason(const std::string& val);

  void __set_Ack_Cancel_Ratio(const std::string& val);

  void __set_OpenClose(const  ::AtsType::OrderOpenClose::type val);

  bool operator == (const OrderMsg & rhs) const
  {
    if (!(Code == rhs.Code))
      return false;
    if (!(Id == rhs.Id))
      return false;
    if (!(TimeStamp == rhs.TimeStamp))
      return false;
    if (!(Active == rhs.Active))
      return false;
    if (!(Way == rhs.Way))
      return false;
    if (!(Action == rhs.Action))
      return false;
    if (!(TradingType == rhs.TradingType))
      return false;
    if (!(Quantity == rhs.Quantity))
      return false;
    if (!(Price == rhs.Price))
      return false;
    if (!(ExecQty == rhs.ExecQty))
      return false;
    if (!(ExecPrice == rhs.ExecPrice))
      return false;
    if (!(BookQty == rhs.BookQty))
      return false;
    if (!(Status == rhs.Status))
      return false;
    if (!(Portfolio == rhs.Portfolio))
      return false;
    if (!(LastReason == rhs.LastReason))
      return false;
    if (!(Ack_Cancel_Ratio == rhs.Ack_Cancel_Ratio))
      return false;
    if (!(OpenClose == rhs.OpenClose))
      return false;
    return true;
  }
  bool operator != (const OrderMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OrderMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(OrderMsg &a, OrderMsg &b);

inline std::ostream& operator<<(std::ostream& out, const OrderMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _QuoteMsg__isset {
  _QuoteMsg__isset() : Code(false), Id(false), TimeStamp(false), TradingType(false), Status(false), Portfolio(false), LastReason(false), BuyOrder(false), SellOrder(false), FQR_ID(false) {}
  bool Code :1;
  bool Id :1;
  bool TimeStamp :1;
  bool TradingType :1;
  bool Status :1;
  bool Portfolio :1;
  bool LastReason :1;
  bool BuyOrder :1;
  bool SellOrder :1;
  bool FQR_ID :1;
} _QuoteMsg__isset;

class QuoteMsg {
 public:

  QuoteMsg(const QuoteMsg&);
  QuoteMsg& operator=(const QuoteMsg&);
  QuoteMsg() : Code(), Id(0), TimeStamp(), TradingType(0), Status(( ::AtsType::OrderStatus::type)0), Portfolio(), LastReason(), FQR_ID() {
  }

  virtual ~QuoteMsg() throw();
  std::string Code;
  int32_t Id;
  std::string TimeStamp;
  int32_t TradingType;
   ::AtsType::OrderStatus::type Status;
  std::string Portfolio;
  std::string LastReason;
  OrderMsg BuyOrder;
  OrderMsg SellOrder;
  std::string FQR_ID;

  _QuoteMsg__isset __isset;

  void __set_Code(const std::string& val);

  void __set_Id(const int32_t val);

  void __set_TimeStamp(const std::string& val);

  void __set_TradingType(const int32_t val);

  void __set_Status(const  ::AtsType::OrderStatus::type val);

  void __set_Portfolio(const std::string& val);

  void __set_LastReason(const std::string& val);

  void __set_BuyOrder(const OrderMsg& val);

  void __set_SellOrder(const OrderMsg& val);

  void __set_FQR_ID(const std::string& val);

  bool operator == (const QuoteMsg & rhs) const
  {
    if (!(Code == rhs.Code))
      return false;
    if (!(Id == rhs.Id))
      return false;
    if (!(TimeStamp == rhs.TimeStamp))
      return false;
    if (!(TradingType == rhs.TradingType))
      return false;
    if (!(Status == rhs.Status))
      return false;
    if (!(Portfolio == rhs.Portfolio))
      return false;
    if (!(LastReason == rhs.LastReason))
      return false;
    if (!(BuyOrder == rhs.BuyOrder))
      return false;
    if (!(SellOrder == rhs.SellOrder))
      return false;
    if (!(FQR_ID == rhs.FQR_ID))
      return false;
    return true;
  }
  bool operator != (const QuoteMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const QuoteMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(QuoteMsg &a, QuoteMsg &b);

inline std::ostream& operator<<(std::ostream& out, const QuoteMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ExecMsg__isset {
  _ExecMsg__isset() : Code(false), Id(false), Way(false), Quantity(false), Price(false), Reference(false), Time(false), TradingType(false), Portfolio(false), OpenClose(false) {}
  bool Code :1;
  bool Id :1;
  bool Way :1;
  bool Quantity :1;
  bool Price :1;
  bool Reference :1;
  bool Time :1;
  bool TradingType :1;
  bool Portfolio :1;
  bool OpenClose :1;
} _ExecMsg__isset;

class ExecMsg {
 public:

  ExecMsg(const ExecMsg&);
  ExecMsg& operator=(const ExecMsg&);
  ExecMsg() : Code(), Id(0), Way(( ::AtsType::OrderWay::type)0), Quantity(0), Price(0), Reference(), Time(), TradingType(0), Portfolio(), OpenClose() {
  }

  virtual ~ExecMsg() throw();
  std::string Code;
  int32_t Id;
   ::AtsType::OrderWay::type Way;
  int32_t Quantity;
  double Price;
  std::string Reference;
  std::string Time;
  int32_t TradingType;
  std::string Portfolio;
  std::string OpenClose;

  _ExecMsg__isset __isset;

  void __set_Code(const std::string& val);

  void __set_Id(const int32_t val);

  void __set_Way(const  ::AtsType::OrderWay::type val);

  void __set_Quantity(const int32_t val);

  void __set_Price(const double val);

  void __set_Reference(const std::string& val);

  void __set_Time(const std::string& val);

  void __set_TradingType(const int32_t val);

  void __set_Portfolio(const std::string& val);

  void __set_OpenClose(const std::string& val);

  bool operator == (const ExecMsg & rhs) const
  {
    if (!(Code == rhs.Code))
      return false;
    if (!(Id == rhs.Id))
      return false;
    if (!(Way == rhs.Way))
      return false;
    if (!(Quantity == rhs.Quantity))
      return false;
    if (!(Price == rhs.Price))
      return false;
    if (!(Reference == rhs.Reference))
      return false;
    if (!(Time == rhs.Time))
      return false;
    if (!(TradingType == rhs.TradingType))
      return false;
    if (!(Portfolio == rhs.Portfolio))
      return false;
    if (!(OpenClose == rhs.OpenClose))
      return false;
    return true;
  }
  bool operator != (const ExecMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExecMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ExecMsg &a, ExecMsg &b);

inline std::ostream& operator<<(std::ostream& out, const ExecMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ListQuoteMsg__isset {
  _ListQuoteMsg__isset() : Quotes(false) {}
  bool Quotes :1;
} _ListQuoteMsg__isset;

class ListQuoteMsg {
 public:

  ListQuoteMsg(const ListQuoteMsg&);
  ListQuoteMsg& operator=(const ListQuoteMsg&);
  ListQuoteMsg() {
  }

  virtual ~ListQuoteMsg() throw();
  std::vector<QuoteMsg>  Quotes;

  _ListQuoteMsg__isset __isset;

  void __set_Quotes(const std::vector<QuoteMsg> & val);

  bool operator == (const ListQuoteMsg & rhs) const
  {
    if (!(Quotes == rhs.Quotes))
      return false;
    return true;
  }
  bool operator != (const ListQuoteMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListQuoteMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListQuoteMsg &a, ListQuoteMsg &b);

inline std::ostream& operator<<(std::ostream& out, const ListQuoteMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ListExecMsg__isset {
  _ListExecMsg__isset() : Execs(false) {}
  bool Execs :1;
} _ListExecMsg__isset;

class ListExecMsg {
 public:

  ListExecMsg(const ListExecMsg&);
  ListExecMsg& operator=(const ListExecMsg&);
  ListExecMsg() {
  }

  virtual ~ListExecMsg() throw();
  std::vector<ExecMsg>  Execs;

  _ListExecMsg__isset __isset;

  void __set_Execs(const std::vector<ExecMsg> & val);

  bool operator == (const ListExecMsg & rhs) const
  {
    if (!(Execs == rhs.Execs))
      return false;
    return true;
  }
  bool operator != (const ListExecMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListExecMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListExecMsg &a, ListExecMsg &b);

inline std::ostream& operator<<(std::ostream& out, const ListExecMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ListOrderMsg__isset {
  _ListOrderMsg__isset() : Orders(false) {}
  bool Orders :1;
} _ListOrderMsg__isset;

class ListOrderMsg {
 public:

  ListOrderMsg(const ListOrderMsg&);
  ListOrderMsg& operator=(const ListOrderMsg&);
  ListOrderMsg() {
  }

  virtual ~ListOrderMsg() throw();
  std::vector<OrderMsg>  Orders;

  _ListOrderMsg__isset __isset;

  void __set_Orders(const std::vector<OrderMsg> & val);

  bool operator == (const ListOrderMsg & rhs) const
  {
    if (!(Orders == rhs.Orders))
      return false;
    return true;
  }
  bool operator != (const ListOrderMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListOrderMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListOrderMsg &a, ListOrderMsg &b);

inline std::ostream& operator<<(std::ostream& out, const ListOrderMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ListLogMsg__isset {
  _ListLogMsg__isset() : Logs(false) {}
  bool Logs :1;
} _ListLogMsg__isset;

class ListLogMsg {
 public:

  ListLogMsg(const ListLogMsg&);
  ListLogMsg& operator=(const ListLogMsg&);
  ListLogMsg() {
  }

  virtual ~ListLogMsg() throw();
  std::vector<LogMsg>  Logs;

  _ListLogMsg__isset __isset;

  void __set_Logs(const std::vector<LogMsg> & val);

  bool operator == (const ListLogMsg & rhs) const
  {
    if (!(Logs == rhs.Logs))
      return false;
    return true;
  }
  bool operator != (const ListLogMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListLogMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ListLogMsg &a, ListLogMsg &b);

inline std::ostream& operator<<(std::ostream& out, const ListLogMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PositionMsg__isset {
  _PositionMsg__isset() : Instrument(false), Portfolio(false), YesterdayPosition(false), TodayPosition(false), TotalPosition(false), TodayBuyPosition(false), TodayBuyPrice(false), TodaySellPosition(false), TodaySellPrice(false), YesterdayPrice(false), YesterdayPriceLocal(false), YesterdayPriceExternal(false), YesterdayPositionLocal(false), YesterdayPositionManual(false), YesterdayPositionExternal(false), UseManualPosition(false), YstPositionType(false), YstPriceType(false), Connection(false), TodayPurPosition(false), TodayRedPosition(false), AccoutTotalPosition(false) {}
  bool Instrument :1;
  bool Portfolio :1;
  bool YesterdayPosition :1;
  bool TodayPosition :1;
  bool TotalPosition :1;
  bool TodayBuyPosition :1;
  bool TodayBuyPrice :1;
  bool TodaySellPosition :1;
  bool TodaySellPrice :1;
  bool YesterdayPrice :1;
  bool YesterdayPriceLocal :1;
  bool YesterdayPriceExternal :1;
  bool YesterdayPositionLocal :1;
  bool YesterdayPositionManual :1;
  bool YesterdayPositionExternal :1;
  bool UseManualPosition :1;
  bool YstPositionType :1;
  bool YstPriceType :1;
  bool Connection :1;
  bool TodayPurPosition :1;
  bool TodayRedPosition :1;
  bool AccoutTotalPosition :1;
} _PositionMsg__isset;

class PositionMsg {
 public:

  PositionMsg(const PositionMsg&);
  PositionMsg& operator=(const PositionMsg&);
  PositionMsg() : Instrument(), Portfolio(), YesterdayPosition(0), TodayPosition(0), TotalPosition(0), TodayBuyPosition(0), TodayBuyPrice(0), TodaySellPosition(0), TodaySellPrice(0), YesterdayPrice(0), YesterdayPriceLocal(0), YesterdayPriceExternal(0), YesterdayPositionLocal(0), YesterdayPositionManual(0), YesterdayPositionExternal(0), UseManualPosition(0), YstPositionType(( ::AtsType::YesterdayPositionType::type)0), YstPriceType(( ::AtsType::YesterdayPriceType::type)0), Connection(), TodayPurPosition(0), TodayRedPosition(0), AccoutTotalPosition(0) {
  }

  virtual ~PositionMsg() throw();
  std::string Instrument;
  std::string Portfolio;
  int32_t YesterdayPosition;
  int32_t TodayPosition;
  int32_t TotalPosition;
  int32_t TodayBuyPosition;
  double TodayBuyPrice;
  int32_t TodaySellPosition;
  double TodaySellPrice;
  double YesterdayPrice;
  double YesterdayPriceLocal;
  double YesterdayPriceExternal;
  int32_t YesterdayPositionLocal;
  int32_t YesterdayPositionManual;
  int32_t YesterdayPositionExternal;
  bool UseManualPosition;
   ::AtsType::YesterdayPositionType::type YstPositionType;
   ::AtsType::YesterdayPriceType::type YstPriceType;
  std::string Connection;
  int32_t TodayPurPosition;
  int32_t TodayRedPosition;
  int32_t AccoutTotalPosition;

  _PositionMsg__isset __isset;

  void __set_Instrument(const std::string& val);

  void __set_Portfolio(const std::string& val);

  void __set_YesterdayPosition(const int32_t val);

  void __set_TodayPosition(const int32_t val);

  void __set_TotalPosition(const int32_t val);

  void __set_TodayBuyPosition(const int32_t val);

  void __set_TodayBuyPrice(const double val);

  void __set_TodaySellPosition(const int32_t val);

  void __set_TodaySellPrice(const double val);

  void __set_YesterdayPrice(const double val);

  void __set_YesterdayPriceLocal(const double val);

  void __set_YesterdayPriceExternal(const double val);

  void __set_YesterdayPositionLocal(const int32_t val);

  void __set_YesterdayPositionManual(const int32_t val);

  void __set_YesterdayPositionExternal(const int32_t val);

  void __set_UseManualPosition(const bool val);

  void __set_YstPositionType(const  ::AtsType::YesterdayPositionType::type val);

  void __set_YstPriceType(const  ::AtsType::YesterdayPriceType::type val);

  void __set_Connection(const std::string& val);

  void __set_TodayPurPosition(const int32_t val);

  void __set_TodayRedPosition(const int32_t val);

  void __set_AccoutTotalPosition(const int32_t val);

  bool operator == (const PositionMsg & rhs) const
  {
    if (!(Instrument == rhs.Instrument))
      return false;
    if (!(Portfolio == rhs.Portfolio))
      return false;
    if (!(YesterdayPosition == rhs.YesterdayPosition))
      return false;
    if (!(TodayPosition == rhs.TodayPosition))
      return false;
    if (!(TotalPosition == rhs.TotalPosition))
      return false;
    if (!(TodayBuyPosition == rhs.TodayBuyPosition))
      return false;
    if (!(TodayBuyPrice == rhs.TodayBuyPrice))
      return false;
    if (!(TodaySellPosition == rhs.TodaySellPosition))
      return false;
    if (!(TodaySellPrice == rhs.TodaySellPrice))
      return false;
    if (!(YesterdayPrice == rhs.YesterdayPrice))
      return false;
    if (!(YesterdayPriceLocal == rhs.YesterdayPriceLocal))
      return false;
    if (!(YesterdayPriceExternal == rhs.YesterdayPriceExternal))
      return false;
    if (!(YesterdayPositionLocal == rhs.YesterdayPositionLocal))
      return false;
    if (!(YesterdayPositionManual == rhs.YesterdayPositionManual))
      return false;
    if (!(YesterdayPositionExternal == rhs.YesterdayPositionExternal))
      return false;
    if (!(UseManualPosition == rhs.UseManualPosition))
      return false;
    if (!(YstPositionType == rhs.YstPositionType))
      return false;
    if (!(YstPriceType == rhs.YstPriceType))
      return false;
    if (!(Connection == rhs.Connection))
      return false;
    if (!(TodayPurPosition == rhs.TodayPurPosition))
      return false;
    if (!(TodayRedPosition == rhs.TodayRedPosition))
      return false;
    if (!(AccoutTotalPosition == rhs.AccoutTotalPosition))
      return false;
    return true;
  }
  bool operator != (const PositionMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PositionMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PositionMsg &a, PositionMsg &b);

inline std::ostream& operator<<(std::ostream& out, const PositionMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FeedMsg__isset {
  _FeedMsg__isset() : Code(false), FeedSourceName(false), Bid(false), Ask(false), BidQuantity(false), AskQuantity(false), Last(false), LastQuantity(false), LastOrClose(false), Mid(false), Close(false), Settlement(false), UpperLimit(false), LowerLimit(false), Perf(false), DailyVolume(false), isBiddAskActive(false), isSuspended(false), MaxDepth(false), BidDepths(false), AskDepths(false), BidQtys(false), AskQtys(false), MarketTime(false) {}
  bool Code :1;
  bool FeedSourceName :1;
  bool Bid :1;
  bool Ask :1;
  bool BidQuantity :1;
  bool AskQuantity :1;
  bool Last :1;
  bool LastQuantity :1;
  bool LastOrClose :1;
  bool Mid :1;
  bool Close :1;
  bool Settlement :1;
  bool UpperLimit :1;
  bool LowerLimit :1;
  bool Perf :1;
  bool DailyVolume :1;
  bool isBiddAskActive :1;
  bool isSuspended :1;
  bool MaxDepth :1;
  bool BidDepths :1;
  bool AskDepths :1;
  bool BidQtys :1;
  bool AskQtys :1;
  bool MarketTime :1;
} _FeedMsg__isset;

class FeedMsg {
 public:

  FeedMsg(const FeedMsg&);
  FeedMsg& operator=(const FeedMsg&);
  FeedMsg() : Code(), FeedSourceName(), Bid(0), Ask(0), BidQuantity(0), AskQuantity(0), Last(0), LastQuantity(0), LastOrClose(0), Mid(0), Close(0), Settlement(0), UpperLimit(0), LowerLimit(0), Perf(0), DailyVolume(0), isBiddAskActive(0), isSuspended(0), MaxDepth(0), MarketTime() {
  }

  virtual ~FeedMsg() throw();
  std::string Code;
  std::string FeedSourceName;
  double Bid;
  double Ask;
  int32_t BidQuantity;
  int32_t AskQuantity;
  double Last;
  int32_t LastQuantity;
  double LastOrClose;
  double Mid;
  double Close;
  double Settlement;
  double UpperLimit;
  double LowerLimit;
  double Perf;
  int64_t DailyVolume;
  bool isBiddAskActive;
  bool isSuspended;
  int32_t MaxDepth;
  std::vector<double>  BidDepths;
  std::vector<double>  AskDepths;
  std::vector<int32_t>  BidQtys;
  std::vector<int32_t>  AskQtys;
  std::string MarketTime;

  _FeedMsg__isset __isset;

  void __set_Code(const std::string& val);

  void __set_FeedSourceName(const std::string& val);

  void __set_Bid(const double val);

  void __set_Ask(const double val);

  void __set_BidQuantity(const int32_t val);

  void __set_AskQuantity(const int32_t val);

  void __set_Last(const double val);

  void __set_LastQuantity(const int32_t val);

  void __set_LastOrClose(const double val);

  void __set_Mid(const double val);

  void __set_Close(const double val);

  void __set_Settlement(const double val);

  void __set_UpperLimit(const double val);

  void __set_LowerLimit(const double val);

  void __set_Perf(const double val);

  void __set_DailyVolume(const int64_t val);

  void __set_isBiddAskActive(const bool val);

  void __set_isSuspended(const bool val);

  void __set_MaxDepth(const int32_t val);

  void __set_BidDepths(const std::vector<double> & val);

  void __set_AskDepths(const std::vector<double> & val);

  void __set_BidQtys(const std::vector<int32_t> & val);

  void __set_AskQtys(const std::vector<int32_t> & val);

  void __set_MarketTime(const std::string& val);

  bool operator == (const FeedMsg & rhs) const
  {
    if (!(Code == rhs.Code))
      return false;
    if (!(FeedSourceName == rhs.FeedSourceName))
      return false;
    if (!(Bid == rhs.Bid))
      return false;
    if (!(Ask == rhs.Ask))
      return false;
    if (!(BidQuantity == rhs.BidQuantity))
      return false;
    if (!(AskQuantity == rhs.AskQuantity))
      return false;
    if (!(Last == rhs.Last))
      return false;
    if (!(LastQuantity == rhs.LastQuantity))
      return false;
    if (!(LastOrClose == rhs.LastOrClose))
      return false;
    if (!(Mid == rhs.Mid))
      return false;
    if (!(Close == rhs.Close))
      return false;
    if (!(Settlement == rhs.Settlement))
      return false;
    if (__isset.UpperLimit != rhs.__isset.UpperLimit)
      return false;
    else if (__isset.UpperLimit && !(UpperLimit == rhs.UpperLimit))
      return false;
    if (__isset.LowerLimit != rhs.__isset.LowerLimit)
      return false;
    else if (__isset.LowerLimit && !(LowerLimit == rhs.LowerLimit))
      return false;
    if (!(Perf == rhs.Perf))
      return false;
    if (!(DailyVolume == rhs.DailyVolume))
      return false;
    if (!(isBiddAskActive == rhs.isBiddAskActive))
      return false;
    if (!(isSuspended == rhs.isSuspended))
      return false;
    if (!(MaxDepth == rhs.MaxDepth))
      return false;
    if (__isset.BidDepths != rhs.__isset.BidDepths)
      return false;
    else if (__isset.BidDepths && !(BidDepths == rhs.BidDepths))
      return false;
    if (__isset.AskDepths != rhs.__isset.AskDepths)
      return false;
    else if (__isset.AskDepths && !(AskDepths == rhs.AskDepths))
      return false;
    if (__isset.BidQtys != rhs.__isset.BidQtys)
      return false;
    else if (__isset.BidQtys && !(BidQtys == rhs.BidQtys))
      return false;
    if (__isset.AskQtys != rhs.__isset.AskQtys)
      return false;
    else if (__isset.AskQtys && !(AskQtys == rhs.AskQtys))
      return false;
    if (!(MarketTime == rhs.MarketTime))
      return false;
    return true;
  }
  bool operator != (const FeedMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FeedMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FeedMsg &a, FeedMsg &b);

inline std::ostream& operator<<(std::ostream& out, const FeedMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AtsInstrumentMsg__isset {
  _AtsInstrumentMsg__isset() : Code(false), Position(false), FeedItem(false), OrderContainer(false), ExchangeFees(false), BrokerFees(false), YesterdayPnlBarycenter(false), TodayPnlBarycenter(false), SizeToSend(false), MarketMakerItemBid(false), MarketMakerItemAsk(false), InstrumentClassName(false) {}
  bool Code :1;
  bool Position :1;
  bool FeedItem :1;
  bool OrderContainer :1;
  bool ExchangeFees :1;
  bool BrokerFees :1;
  bool YesterdayPnlBarycenter :1;
  bool TodayPnlBarycenter :1;
  bool SizeToSend :1;
  bool MarketMakerItemBid :1;
  bool MarketMakerItemAsk :1;
  bool InstrumentClassName :1;
} _AtsInstrumentMsg__isset;

class AtsInstrumentMsg {
 public:

  AtsInstrumentMsg(const AtsInstrumentMsg&);
  AtsInstrumentMsg& operator=(const AtsInstrumentMsg&);
  AtsInstrumentMsg() : Code(), ExchangeFees(0), BrokerFees(0), YesterdayPnlBarycenter(0), TodayPnlBarycenter(0), SizeToSend(0), InstrumentClassName() {
  }

  virtual ~AtsInstrumentMsg() throw();
  std::string Code;
  PositionMsg Position;
  FeedMsg FeedItem;
  std::map<int32_t, std::map<int32_t, OrderMsg> >  OrderContainer;
  double ExchangeFees;
  double BrokerFees;
  double YesterdayPnlBarycenter;
  double TodayPnlBarycenter;
  int32_t SizeToSend;
  std::map<double, int32_t>  MarketMakerItemBid;
  std::map<double, int32_t>  MarketMakerItemAsk;
  std::string InstrumentClassName;

  _AtsInstrumentMsg__isset __isset;

  void __set_Code(const std::string& val);

  void __set_Position(const PositionMsg& val);

  void __set_FeedItem(const FeedMsg& val);

  void __set_OrderContainer(const std::map<int32_t, std::map<int32_t, OrderMsg> > & val);

  void __set_ExchangeFees(const double val);

  void __set_BrokerFees(const double val);

  void __set_YesterdayPnlBarycenter(const double val);

  void __set_TodayPnlBarycenter(const double val);

  void __set_SizeToSend(const int32_t val);

  void __set_MarketMakerItemBid(const std::map<double, int32_t> & val);

  void __set_MarketMakerItemAsk(const std::map<double, int32_t> & val);

  void __set_InstrumentClassName(const std::string& val);

  bool operator == (const AtsInstrumentMsg & rhs) const
  {
    if (!(Code == rhs.Code))
      return false;
    if (!(Position == rhs.Position))
      return false;
    if (!(FeedItem == rhs.FeedItem))
      return false;
    if (!(OrderContainer == rhs.OrderContainer))
      return false;
    if (!(ExchangeFees == rhs.ExchangeFees))
      return false;
    if (!(BrokerFees == rhs.BrokerFees))
      return false;
    if (!(YesterdayPnlBarycenter == rhs.YesterdayPnlBarycenter))
      return false;
    if (!(TodayPnlBarycenter == rhs.TodayPnlBarycenter))
      return false;
    if (!(SizeToSend == rhs.SizeToSend))
      return false;
    if (!(MarketMakerItemBid == rhs.MarketMakerItemBid))
      return false;
    if (!(MarketMakerItemAsk == rhs.MarketMakerItemAsk))
      return false;
    if (!(InstrumentClassName == rhs.InstrumentClassName))
      return false;
    return true;
  }
  bool operator != (const AtsInstrumentMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AtsInstrumentMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AtsInstrumentMsg &a, AtsInstrumentMsg &b);

inline std::ostream& operator<<(std::ostream& out, const AtsInstrumentMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AtsMsg__isset {
  _AtsMsg__isset() : Name(false), AutoStatus(false), YesterdayPositionType(false), YesterdayPnlBary(false), TodayPnlBary(false), YesterdayPnlMid(false), TodayPnlMid(false), YesterdayPnlLast(false), TodayPnlLast(false), FeesExchange(false), FeesBroker(false), TotalPnl(false) {}
  bool Name :1;
  bool AutoStatus :1;
  bool YesterdayPositionType :1;
  bool YesterdayPnlBary :1;
  bool TodayPnlBary :1;
  bool YesterdayPnlMid :1;
  bool TodayPnlMid :1;
  bool YesterdayPnlLast :1;
  bool TodayPnlLast :1;
  bool FeesExchange :1;
  bool FeesBroker :1;
  bool TotalPnl :1;
} _AtsMsg__isset;

class AtsMsg {
 public:

  AtsMsg(const AtsMsg&);
  AtsMsg& operator=(const AtsMsg&);
  AtsMsg() : Name(), AutoStatus(0), YesterdayPositionType(( ::AtsType::YesterdayPositionType::type)0), YesterdayPnlBary(0), TodayPnlBary(0), YesterdayPnlMid(0), TodayPnlMid(0), YesterdayPnlLast(0), TodayPnlLast(0), FeesExchange(0), FeesBroker(0), TotalPnl(0) {
  }

  virtual ~AtsMsg() throw();
  std::string Name;
  bool AutoStatus;
   ::AtsType::YesterdayPositionType::type YesterdayPositionType;
  double YesterdayPnlBary;
  double TodayPnlBary;
  double YesterdayPnlMid;
  double TodayPnlMid;
  double YesterdayPnlLast;
  double TodayPnlLast;
  double FeesExchange;
  double FeesBroker;
  double TotalPnl;

  _AtsMsg__isset __isset;

  void __set_Name(const std::string& val);

  void __set_AutoStatus(const bool val);

  void __set_YesterdayPositionType(const  ::AtsType::YesterdayPositionType::type val);

  void __set_YesterdayPnlBary(const double val);

  void __set_TodayPnlBary(const double val);

  void __set_YesterdayPnlMid(const double val);

  void __set_TodayPnlMid(const double val);

  void __set_YesterdayPnlLast(const double val);

  void __set_TodayPnlLast(const double val);

  void __set_FeesExchange(const double val);

  void __set_FeesBroker(const double val);

  void __set_TotalPnl(const double val);

  bool operator == (const AtsMsg & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(AutoStatus == rhs.AutoStatus))
      return false;
    if (!(YesterdayPositionType == rhs.YesterdayPositionType))
      return false;
    if (!(YesterdayPnlBary == rhs.YesterdayPnlBary))
      return false;
    if (!(TodayPnlBary == rhs.TodayPnlBary))
      return false;
    if (!(YesterdayPnlMid == rhs.YesterdayPnlMid))
      return false;
    if (!(TodayPnlMid == rhs.TodayPnlMid))
      return false;
    if (!(YesterdayPnlLast == rhs.YesterdayPnlLast))
      return false;
    if (!(TodayPnlLast == rhs.TodayPnlLast))
      return false;
    if (!(FeesExchange == rhs.FeesExchange))
      return false;
    if (!(FeesBroker == rhs.FeesBroker))
      return false;
    if (!(TotalPnl == rhs.TotalPnl))
      return false;
    return true;
  }
  bool operator != (const AtsMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AtsMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AtsMsg &a, AtsMsg &b);

inline std::ostream& operator<<(std::ostream& out, const AtsMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FeesStructMsg__isset {
  _FeesStructMsg__isset() : ClassName(false), FeesFloatExchange(false), FeesFloatBroker(false), FeesFixExchange(false), FeesFixBroker(false), FeesSellAmount(false), NotCloseToday(false) {}
  bool ClassName :1;
  bool FeesFloatExchange :1;
  bool FeesFloatBroker :1;
  bool FeesFixExchange :1;
  bool FeesFixBroker :1;
  bool FeesSellAmount :1;
  bool NotCloseToday :1;
} _FeesStructMsg__isset;

class FeesStructMsg {
 public:

  FeesStructMsg(const FeesStructMsg&);
  FeesStructMsg& operator=(const FeesStructMsg&);
  FeesStructMsg() : ClassName(), FeesFloatExchange(0), FeesFloatBroker(0), FeesFixExchange(0), FeesFixBroker(0), FeesSellAmount(0), NotCloseToday(0) {
  }

  virtual ~FeesStructMsg() throw();
  std::string ClassName;
  double FeesFloatExchange;
  double FeesFloatBroker;
  double FeesFixExchange;
  double FeesFixBroker;
  double FeesSellAmount;
  bool NotCloseToday;

  _FeesStructMsg__isset __isset;

  void __set_ClassName(const std::string& val);

  void __set_FeesFloatExchange(const double val);

  void __set_FeesFloatBroker(const double val);

  void __set_FeesFixExchange(const double val);

  void __set_FeesFixBroker(const double val);

  void __set_FeesSellAmount(const double val);

  void __set_NotCloseToday(const bool val);

  bool operator == (const FeesStructMsg & rhs) const
  {
    if (!(ClassName == rhs.ClassName))
      return false;
    if (!(FeesFloatExchange == rhs.FeesFloatExchange))
      return false;
    if (!(FeesFloatBroker == rhs.FeesFloatBroker))
      return false;
    if (!(FeesFixExchange == rhs.FeesFixExchange))
      return false;
    if (!(FeesFixBroker == rhs.FeesFixBroker))
      return false;
    if (!(FeesSellAmount == rhs.FeesSellAmount))
      return false;
    if (!(NotCloseToday == rhs.NotCloseToday))
      return false;
    return true;
  }
  bool operator != (const FeesStructMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FeesStructMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FeesStructMsg &a, FeesStructMsg &b);

inline std::ostream& operator<<(std::ostream& out, const FeesStructMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InstrumentClassMsg__isset {
  _InstrumentClassMsg__isset() : Name(false), FeesStruct(false), MaturityTime(false), Maturities(false), PointValue(false), Currency(false) {}
  bool Name :1;
  bool FeesStruct :1;
  bool MaturityTime :1;
  bool Maturities :1;
  bool PointValue :1;
  bool Currency :1;
} _InstrumentClassMsg__isset;

class InstrumentClassMsg {
 public:

  InstrumentClassMsg(const InstrumentClassMsg&);
  InstrumentClassMsg& operator=(const InstrumentClassMsg&);
  InstrumentClassMsg() : Name(), MaturityTime(), PointValue(0), Currency() {
  }

  virtual ~InstrumentClassMsg() throw();
  std::string Name;
  FeesStructMsg FeesStruct;
  std::string MaturityTime;
  std::vector<MaturityMsg>  Maturities;
  int32_t PointValue;
  std::string Currency;

  _InstrumentClassMsg__isset __isset;

  void __set_Name(const std::string& val);

  void __set_FeesStruct(const FeesStructMsg& val);

  void __set_MaturityTime(const std::string& val);

  void __set_Maturities(const std::vector<MaturityMsg> & val);

  void __set_PointValue(const int32_t val);

  void __set_Currency(const std::string& val);

  bool operator == (const InstrumentClassMsg & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(FeesStruct == rhs.FeesStruct))
      return false;
    if (__isset.MaturityTime != rhs.__isset.MaturityTime)
      return false;
    else if (__isset.MaturityTime && !(MaturityTime == rhs.MaturityTime))
      return false;
    if (__isset.Maturities != rhs.__isset.Maturities)
      return false;
    else if (__isset.Maturities && !(Maturities == rhs.Maturities))
      return false;
    if (!(PointValue == rhs.PointValue))
      return false;
    if (!(Currency == rhs.Currency))
      return false;
    return true;
  }
  bool operator != (const InstrumentClassMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InstrumentClassMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InstrumentClassMsg &a, InstrumentClassMsg &b);

inline std::ostream& operator<<(std::ostream& out, const InstrumentClassMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MaturityMsg__isset {
  _MaturityMsg__isset() : MaturityStr(false), OpenDays(false), OffDays(false), Actu(false), MaturityTime(false) {}
  bool MaturityStr :1;
  bool OpenDays :1;
  bool OffDays :1;
  bool Actu :1;
  bool MaturityTime :1;
} _MaturityMsg__isset;

class MaturityMsg {
 public:

  MaturityMsg(const MaturityMsg&);
  MaturityMsg& operator=(const MaturityMsg&);
  MaturityMsg() : MaturityStr(), OpenDays(0), OffDays(0), Actu(0), MaturityTime() {
  }

  virtual ~MaturityMsg() throw();
  std::string MaturityStr;
  double OpenDays;
  int32_t OffDays;
  double Actu;
  std::string MaturityTime;

  _MaturityMsg__isset __isset;

  void __set_MaturityStr(const std::string& val);

  void __set_OpenDays(const double val);

  void __set_OffDays(const int32_t val);

  void __set_Actu(const double val);

  void __set_MaturityTime(const std::string& val);

  bool operator == (const MaturityMsg & rhs) const
  {
    if (!(MaturityStr == rhs.MaturityStr))
      return false;
    if (!(OpenDays == rhs.OpenDays))
      return false;
    if (!(OffDays == rhs.OffDays))
      return false;
    if (!(Actu == rhs.Actu))
      return false;
    if (!(MaturityTime == rhs.MaturityTime))
      return false;
    return true;
  }
  bool operator != (const MaturityMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MaturityMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MaturityMsg &a, MaturityMsg &b);

inline std::ostream& operator<<(std::ostream& out, const MaturityMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _UnderlyingMsg__isset {
  _UnderlyingMsg__isset() : Name(false), DaysOffList(false), Rate(false), FutureClassList(false), OptionClassList(false), StockClass(false) {}
  bool Name :1;
  bool DaysOffList :1;
  bool Rate :1;
  bool FutureClassList :1;
  bool OptionClassList :1;
  bool StockClass :1;
} _UnderlyingMsg__isset;

class UnderlyingMsg {
 public:

  UnderlyingMsg(const UnderlyingMsg&);
  UnderlyingMsg& operator=(const UnderlyingMsg&);
  UnderlyingMsg() : Name(), Rate(0) {
  }

  virtual ~UnderlyingMsg() throw();
  std::string Name;
  std::vector<std::string>  DaysOffList;
  double Rate;
  std::vector<InstrumentClassMsg>  FutureClassList;
  std::vector<InstrumentClassMsg>  OptionClassList;
  InstrumentClassMsg StockClass;

  _UnderlyingMsg__isset __isset;

  void __set_Name(const std::string& val);

  void __set_DaysOffList(const std::vector<std::string> & val);

  void __set_Rate(const double val);

  void __set_FutureClassList(const std::vector<InstrumentClassMsg> & val);

  void __set_OptionClassList(const std::vector<InstrumentClassMsg> & val);

  void __set_StockClass(const InstrumentClassMsg& val);

  bool operator == (const UnderlyingMsg & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(DaysOffList == rhs.DaysOffList))
      return false;
    if (!(Rate == rhs.Rate))
      return false;
    if (!(FutureClassList == rhs.FutureClassList))
      return false;
    if (!(OptionClassList == rhs.OptionClassList))
      return false;
    if (__isset.StockClass != rhs.__isset.StockClass)
      return false;
    else if (__isset.StockClass && !(StockClass == rhs.StockClass))
      return false;
    return true;
  }
  bool operator != (const UnderlyingMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnderlyingMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UnderlyingMsg &a, UnderlyingMsg &b);

inline std::ostream& operator<<(std::ostream& out, const UnderlyingMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TradingPeriodMsg__isset {
  _TradingPeriodMsg__isset() : StartTime(false), StopTime(false), Phase(false), AutoStopInterval(false) {}
  bool StartTime :1;
  bool StopTime :1;
  bool Phase :1;
  bool AutoStopInterval :1;
} _TradingPeriodMsg__isset;

class TradingPeriodMsg {
 public:

  TradingPeriodMsg(const TradingPeriodMsg&);
  TradingPeriodMsg& operator=(const TradingPeriodMsg&);
  TradingPeriodMsg() : StartTime(), StopTime(), Phase(( ::AtsType::TradingPhase::type)0), AutoStopInterval(0) {
  }

  virtual ~TradingPeriodMsg() throw();
  std::string StartTime;
  std::string StopTime;
   ::AtsType::TradingPhase::type Phase;
  int32_t AutoStopInterval;

  _TradingPeriodMsg__isset __isset;

  void __set_StartTime(const std::string& val);

  void __set_StopTime(const std::string& val);

  void __set_Phase(const  ::AtsType::TradingPhase::type val);

  void __set_AutoStopInterval(const int32_t val);

  bool operator == (const TradingPeriodMsg & rhs) const
  {
    if (!(StartTime == rhs.StartTime))
      return false;
    if (!(StopTime == rhs.StopTime))
      return false;
    if (!(Phase == rhs.Phase))
      return false;
    if (!(AutoStopInterval == rhs.AutoStopInterval))
      return false;
    return true;
  }
  bool operator != (const TradingPeriodMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TradingPeriodMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TradingPeriodMsg &a, TradingPeriodMsg &b);

inline std::ostream& operator<<(std::ostream& out, const TradingPeriodMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TradingPeriodManagerMsg__isset {
  _TradingPeriodManagerMsg__isset() : TradingPeriodList(false), ShiftPriceTime(false), ShiftEodTime(false), ShiftEodTimeN(false) {}
  bool TradingPeriodList :1;
  bool ShiftPriceTime :1;
  bool ShiftEodTime :1;
  bool ShiftEodTimeN :1;
} _TradingPeriodManagerMsg__isset;

class TradingPeriodManagerMsg {
 public:

  TradingPeriodManagerMsg(const TradingPeriodManagerMsg&);
  TradingPeriodManagerMsg& operator=(const TradingPeriodManagerMsg&);
  TradingPeriodManagerMsg() : ShiftPriceTime(), ShiftEodTime(), ShiftEodTimeN() {
  }

  virtual ~TradingPeriodManagerMsg() throw();
  std::vector<TradingPeriodMsg>  TradingPeriodList;
  std::string ShiftPriceTime;
  std::string ShiftEodTime;
  std::string ShiftEodTimeN;

  _TradingPeriodManagerMsg__isset __isset;

  void __set_TradingPeriodList(const std::vector<TradingPeriodMsg> & val);

  void __set_ShiftPriceTime(const std::string& val);

  void __set_ShiftEodTime(const std::string& val);

  void __set_ShiftEodTimeN(const std::string& val);

  bool operator == (const TradingPeriodManagerMsg & rhs) const
  {
    if (!(TradingPeriodList == rhs.TradingPeriodList))
      return false;
    if (!(ShiftPriceTime == rhs.ShiftPriceTime))
      return false;
    if (!(ShiftEodTime == rhs.ShiftEodTime))
      return false;
    if (!(ShiftEodTimeN == rhs.ShiftEodTimeN))
      return false;
    return true;
  }
  bool operator != (const TradingPeriodManagerMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TradingPeriodManagerMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TradingPeriodManagerMsg &a, TradingPeriodManagerMsg &b);

inline std::ostream& operator<<(std::ostream& out, const TradingPeriodManagerMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IntraDataMsg__isset {
  _IntraDataMsg__isset() : name(false), time(false), datas(false) {}
  bool name :1;
  bool time :1;
  bool datas :1;
} _IntraDataMsg__isset;

class IntraDataMsg {
 public:

  IntraDataMsg(const IntraDataMsg&);
  IntraDataMsg& operator=(const IntraDataMsg&);
  IntraDataMsg() : name(), time() {
  }

  virtual ~IntraDataMsg() throw();
  std::string name;
  std::string time;
  std::map<std::string, double>  datas;

  _IntraDataMsg__isset __isset;

  void __set_name(const std::string& val);

  void __set_time(const std::string& val);

  void __set_datas(const std::map<std::string, double> & val);

  bool operator == (const IntraDataMsg & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(time == rhs.time))
      return false;
    if (!(datas == rhs.datas))
      return false;
    return true;
  }
  bool operator != (const IntraDataMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntraDataMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IntraDataMsg &a, IntraDataMsg &b);

inline std::ostream& operator<<(std::ostream& out, const IntraDataMsg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AESDataMsg__isset {
  _AESDataMsg__isset() : num(false), date(false), time_t(false) {}
  bool num :1;
  bool date :1;
  bool time_t :1;
} _AESDataMsg__isset;

class AESDataMsg {
 public:

  AESDataMsg(const AESDataMsg&);
  AESDataMsg& operator=(const AESDataMsg&);
  AESDataMsg() : num(), date(), time_t() {
  }

  virtual ~AESDataMsg() throw();
  std::string num;
  std::string date;
  std::string time_t;

  _AESDataMsg__isset __isset;

  void __set_num(const std::string& val);

  void __set_date(const std::string& val);

  void __set_time_t(const std::string& val);

  bool operator == (const AESDataMsg & rhs) const
  {
    if (!(num == rhs.num))
      return false;
    if (!(date == rhs.date))
      return false;
    if (!(time_t == rhs.time_t))
      return false;
    return true;
  }
  bool operator != (const AESDataMsg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AESDataMsg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AESDataMsg &a, AESDataMsg &b);

inline std::ostream& operator<<(std::ostream& out, const AESDataMsg& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
